// paper: https://eprint.iacr.org/2024/039.pdf
// note: the require from mlkem768 is missing on purpose

from Formosa_MLKEM require "kem.jinc"
require "params.jinc"
require "fips202.jinc"

inline
fn expand_decaps_key(
    reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES] expanded_skp, 
    reg ptr u8[XWING_PUBLICKEYBYTES] pkp, 
    reg ptr u8[XWING_SEEDBYTES] sk) 
    -> reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES], reg ptr[XWING_PUBLICKEYBYTES] 
{
  
  stack u8[XWING_EXPANDED_SEEDBYTES] expanded;
  reg ptr u8[XWING_EXPANDED_SEEDBYTES] expandedp;
        
  expandedp = expanded;    
  expandedp = _shake256_96A_A32(expandedp, sk);
  
  () = #spill(expandedp);
  
  pkp, expanded_skp = __crypto_kem_keypair_jazz(pkp, expanded_skp, expandedp); 
  
  expanded_skp[MLKEM_SECRETKEYBYTES:X25519_BYTES] = #copy(expandedp[XWING_BYTES*2:XWING_BYTES]);
  
  pkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES] = xwing_x25519_base(pkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES], expanded_skp[MLKEM_SECRETKEYBYTES:X25519_BYTES]);
  
  return expanded_skp, pkp;  
}


fn _crypto_xkem_keypair_derand_jazz(
    reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES] skp, 
    reg ptr u8[XWING_PUBLICKEYBYTES] pkp, 
    reg ptr u8[XWING_SEEDBYTES] randomness) 
    -> reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES], reg ptr[XWING_PUBLICKEYBYTES]
{
     skp, pkp = expand_decaps_key(skp, pkp, randomness);
     return skp; pkp;
 
}

fn _crypto_xkem_enc_derand_jazz(
    reg ptr u8[XWING_CIPHERTEXTBYTES] ctp, 
    reg ptr u8[XWING_BYTES] shkp,
    reg ptr u8[XWING_PUBLICKEYBYTES] pkp, 
    reg ptr u8[XWING_ENC_SEEDBYTES] eseed)
    -> reg ptr u8[XWING_CIPHERTEXTBYTES], reg ptr u8[XWING_BYTES]
{
  
  reg ptr u8[XWING_HASH_INPUTBYTES] inp;
  stack u8[XWING_HASH_INPUTBYTES] in;
  inp = in;
  
  inp[0:XWING_LABEL_BYTES] = #copy(XWING_LABEL);
  
  () = #spill(pkp, eseed);

  ctp, inp[XWING_LABEL_BYTES:XWING_LABEL_BYTES + MLKEM_SYMBYTES] =  __crypto_kem_enc_jazz(ctp, inp[XWING_LABEL_BYTES:XWING_LABEL_BYTES+MLKEM_SYMBYTES], pkp, randomness);  
  ctp[MLKEM_CIPHERTEXTBYTES:X25519_BYTES] = xwing_x25519_base(ctp[MLKEM_CIPHERTEXTBYTES:X25519], randomness[XWING_BYTES:XWING_BYTES]);
  inp[XWING_LABEL_BYTES + MLKEM_SYMBYTES:X25519_BYTES] = #copy(ctp[MLKEM_CIPHERTEXTBYTES:X25519_BYTES]);  
  inp[XWING_LABEL_BYTES + MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES] = xwing_x25519(inp[XWING_LABEL_BYTES + MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES], randomness[XWING_BYTES:XWING_BYTES], pkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES]);

  shkp = _sha3_A256_A134(shkp, inp);
  
  return ctp, shkp;
}


fn _crypto_xkem_dec_jazz(
  reg ptr u8[XWING_BYTES] shkp,
  reg ptr u8[XWING_CIPHERTEXTBYTES] ctp,
  reg ptr u8[XWING_SECRETKEYBYTES] skp)
  -> reg ptr u8[XWING_CIPHERTEXTBYTES]
{
  reg ptr u8[XWING_PUBLICKEYBYTES] pkp;
  stack u8[XWING_PUBLICKEYBYTES] pk;
  reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES] expanded_skp;
  stack u8[XWING_EXPANDED_SECRETKEYBYTES] expanded_sk;
  reg ptr u8[XWING_HASH_INPUTBYTES] inp;
  stack u8[XWING_HASH_INPUTBYTES] in;
  
  () = #spill(ctp, skp, shkp);
    
  inp = in;
  pkp = pk;
  expanded_skp = expanded_sk;
    
  expanded_skp, pkp = expand_decaps_key(expanded_skp, pkp, skp);
  
  () = #spill(expanded_skp, pkp);
      
  inp[0:XWING_LABEL_BYTES] = #copy(XWING_LABEL);
  inp[XWING_LABEL_BYTES:XWING_LABEL_BYTES + MLKEM_SYMBYTES] = __crypto_kem_dec_jazz(ctp, expanded_skp);
  inp[XWING_LABEL_BYTES + MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES] = xwing_x25519(inp[XWING_LABEL_BYTES + MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES], expanded_skp[MLKEM_SECRETKEYBYTES:XWING_BYTES], ctp[MLKEM_CIPHERTEXTBYTES:X25519_BYTES]);
  
  () = #spill(inp);
  () = #unspill(shkp);
  shkp = _sha3_A256_A134(shkp, inp);
  
  return shkp;
}
