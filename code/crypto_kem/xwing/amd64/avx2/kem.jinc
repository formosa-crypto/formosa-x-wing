// paper: https://eprint.iacr.org/2024/039.pdf
// note: the require from mlkem768 is missing on purpose

from formosamlkem require "kem.jinc"
require "params.jinc"
require "fips202.jinc"
require "xwing25519.jinc"

inline
fn expand_decaps_key(
    reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES] expanded_skp, 
    reg ptr u8[XWING_PUBLICKEYBYTES] pkp, 
    reg ptr u8[XWING_SEEDBYTES] sk) 
    -> reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES], reg ptr u8[XWING_PUBLICKEYBYTES]
{
  
  stack u8[XWING_EXPANDED_SEEDBYTES] expanded;
  reg ptr u8[XWING_EXPANDED_SEEDBYTES] expandedp;
        
  expandedp = expanded;    
  expandedp = _shake256_A96__A32(expandedp, sk);
  
  () = #spill(expandedp);
  
  pkp[0:MLKEM_PUBLICKEYBYTES], expanded_skp[0:MLKEM_SECRETKEYBYTES] = __crypto_kem_keypair_jazz(pkp[0:MLKEM_PUBLICKEYBYTES], expanded_skp[0:MLKEM_SECRETKEYBYTES], expandedp[0:XWING_BYTES*2]); 
  
  expanded_skp[MLKEM_SECRETKEYBYTES:X25519_BYTES] = #copy(expandedp[XWING_BYTES*2:XWING_BYTES]);
  
  pkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES] = xwing_x25519_base(pkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES], expanded_skp[MLKEM_SECRETKEYBYTES:X25519_BYTES]);
  
  return expanded_skp, pkp;  
}


fn _crypto_xkem_keypair_derand_jazz(
    reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES] skp, 
    reg ptr u8[XWING_PUBLICKEYBYTES] pkp, 
    reg ptr u8[XWING_SEEDBYTES] randomness) 
    -> reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES], reg ptr u8[XWING_PUBLICKEYBYTES]
{
     skp, pkp = expand_decaps_key(skp, pkp, randomness);
     return skp, pkp;
 
}

fn _crypto_xkem_enc_derand_jazz(
    reg ptr u8[XWING_CIPHERTEXTBYTES] ctp, 
    reg ptr u8[XWING_BYTES] shkp,
    reg ptr u8[XWING_PUBLICKEYBYTES] pkp, 
    reg ptr u8[XWING_ENC_SEEDBYTES] eseed)
    -> reg ptr u8[XWING_CIPHERTEXTBYTES], reg ptr u8[XWING_BYTES]
{
  
  reg ptr u8[XWING_HASH_INPUTBYTES] inp;
  stack u8[XWING_HASH_INPUTBYTES] in;
  
  inline int i;
  for i=0 to 6
  { in[u8 i] = XWING_LABEL[i]; }
  
  inp = in;
  () = #spill(pkp, eseed);

  ctp[0:MLKEM_CIPHERTEXTBYTES], inp.[XWING_LABEL_BYTES:MLKEM_SYMBYTES] =  __crypto_kem_enc_jazz(ctp[0:MLKEM_CIPHERTEXTBYTES], inp.[XWING_LABEL_BYTES:MLKEM_SYMBYTES], pkp[0:MLKEM_PUBLICKEYBYTES], eseed[0:XWING_BYTES]);  
  ctp[MLKEM_CIPHERTEXTBYTES:X25519_BYTES] = xwing_x25519_base(ctp[MLKEM_CIPHERTEXTBYTES:X25519_BYTES], eseed[XWING_BYTES:XWING_BYTES]);
  inp.[XWING_LABEL_BYTES + MLKEM_SYMBYTES:X25519_BYTES] = #copy(ctp[MLKEM_CIPHERTEXTBYTES:X25519_BYTES]);  
  inp.[XWING_LABEL_BYTES + MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES] = xwing_x25519(inp.[XWING_LABEL_BYTES + MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES], eseed[XWING_BYTES:XWING_BYTES], pkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES]);

  shkp = _sha3_256__A134(shkp, inp);
  
  return ctp, shkp;
}


fn _crypto_xkem_dec_jazz(
  reg ptr u8[XWING_BYTES] shkp,
  reg ptr u8[XWING_CIPHERTEXTBYTES] ctp,
  reg ptr u8[XWING_SECRETKEYBYTES] skp)
  -> reg ptr u8[XWING_BYTES]
{
  reg ptr u8[XWING_PUBLICKEYBYTES] pkp;
  stack u8[XWING_PUBLICKEYBYTES] pk;
  reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES] expanded_skp;
  stack u8[XWING_EXPANDED_SECRETKEYBYTES] expanded_sk;
  reg ptr u8[XWING_HASH_INPUTBYTES] inp;
  stack u8[XWING_HASH_INPUTBYTES] in;
  
  () = #spill(ctp, skp, shkp);
    
  pkp = pk;
  expanded_skp = expanded_sk;
    
  expanded_skp, pkp = expand_decaps_key(expanded_skp, pkp, skp);
  
  () = #spill(expanded_skp, pkp);
  
  inline int i;
  for i=0 to 6
  { inp[u8 i] = XWING_LABEL[i]; }
  inp = in;
  
  inp.[XWING_LABEL_BYTES:MLKEM_SYMBYTES] = __crypto_kem_dec_jazz(inp.[XWING_LABEL_BYTES:MLKEM_SYMBYTES], ctp[0:MLKEM_CIPHERTEXTBYTES], expanded_skp[0:MLKEM_SECRETKEYBYTES]);
  inp.[XWING_LABEL_BYTES + MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES] = xwing_x25519(inp.[XWING_LABEL_BYTES + MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES], expanded_skp[MLKEM_SECRETKEYBYTES:XWING_BYTES], ctp[MLKEM_CIPHERTEXTBYTES:X25519_BYTES]);
  
  () = #spill(inp);
  () = #unspill(shkp);
  shkp = _sha3_256__A134(shkp, inp);
  
  return shkp;
}
