// paper: https://eprint.iacr.org/2024/039.pdf

from formosamlkem require "kem.jinc"
require "params.jinc"
require "fips202.jinc"
require "xwing25519.jinc"

fn _crypto_xkem_keypair_derand_jazz(
    reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES] skp, 
    reg ptr u8[XWING_PUBLICKEYBYTES] pkp, 
    reg ptr u8[XWING_SEEDBYTES] randomness) 
    -> reg ptr u8[XWING_EXPANDED_SECRETKEYBYTES], reg ptr u8[XWING_PUBLICKEYBYTES]
{
  stack u8[96] expanded;
  stack u8[XWING_PUBLICKEYBYTES] spkp;
  stack u8[XWING_EXPANDED_SECRETKEYBYTES] sskp;
  
  () = #spill(pkp, skp, randomness);
  
  expanded = _shake256_A96__A32(expanded, randomness);
    
  spkp[0:MLKEM_PUBLICKEYBYTES], sskp[0:MLKEM_SECRETKEYBYTES] = __crypto_kem_keypair_jazz(spkp[0:MLKEM_PUBLICKEYBYTES], sskp[0:MLKEM_SECRETKEYBYTES], expanded[0:XWING_BYTES*2]);   
  spkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES] = xwing_x25519_base(spkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES], expanded[XWING_BYTES*2:X25519_BYTES]);
     
  () = #unspill(skp, pkp);
  pkp = #copy(spkp);
  skp = #copy(sskp);
  
  return skp, pkp;
}


fn _crypto_xkem_enc_derand_jazz(
    reg ptr u8[XWING_CIPHERTEXTBYTES] ctp, 
    reg ptr u8[XWING_BYTES] shkp,
    reg ptr u8[XWING_PUBLICKEYBYTES] pkp, 
    reg ptr u8[XWING_ENC_SEEDBYTES] eseed)
    -> reg ptr u8[XWING_CIPHERTEXTBYTES], reg ptr u8[XWING_BYTES]
{
  stack u8[XWING_HASH_INPUTBYTES] in;
  stack u8[XWING_CIPHERTEXTBYTES] sctp;
  stack u8[XWING_BYTES] sshkp;
  stack u8[XWING_PUBLICKEYBYTES] spkp;
  stack u8[XWING_ENC_SEEDBYTES] seseed;
  
  () = #spill(ctp, shkp, pkp, eseed);
  
  spkp = #copy(pkp);  // Unsure why we need to make a copy of this reg ptr (weird ABI rules?)
  seseed = #copy(eseed); // Unsure why we need to make a copy of this reg ptr (weird ABI rules?)
                  
  in[MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES] = xwing_x25519(sctp[MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES], seseed[XWING_BYTES:XWING_BYTES], spkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES]);
  
  sctp[0:MLKEM_CIPHERTEXTBYTES], in[0:MLKEM_SYMBYTES] =  __crypto_kem_enc_jazz(sctp[0:MLKEM_CIPHERTEXTBYTES], in[0:MLKEM_SYMBYTES], spkp[0:MLKEM_PUBLICKEYBYTES], seseed[0:XWING_BYTES]);  
  sctp[MLKEM_CIPHERTEXTBYTES:X25519_BYTES] = xwing_x25519_base(sctp[MLKEM_CIPHERTEXTBYTES:X25519_BYTES], seseed[XWING_BYTES:XWING_BYTES]);
    
  sshkp = _sha3_256_A6__A128(sshkp, in); 
    
  () = #unspill(shkp, ctp);
  
  ctp = #copy(sctp);
  shkp = #copy(sshkp);  
    
  return ctp, shkp;
}


fn _crypto_xkem_dec_jazz(
  reg ptr u8[XWING_BYTES] shkp,
  reg ptr u8[XWING_CIPHERTEXTBYTES] ctp,
  reg ptr u8[XWING_SECRETKEYBYTES] skp)
  -> reg ptr u8[XWING_BYTES]
{
  stack u8[96] expanded;
  stack u8[XWING_HASH_INPUTBYTES] in;
  stack u8[XWING_BYTES] sshkp;
  stack u8[XWING_PUBLICKEYBYTES] spkp;
  stack u8[XWING_CIPHERTEXTBYTES] sctp;
  stack u8[XWING_EXPANDED_SECRETKEYBYTES] expanded_sk;
  
  () = #spill(shkp, ctp, skp);
  
  sctp = #copy(ctp); // Unsure why we need to make a copy of this reg ptr, will not work otherwise (weird ABI rules?)
  
  expanded = _shake256_A96__A32(expanded, skp);
  
  spkp[0:MLKEM_PUBLICKEYBYTES], expanded_sk[0:MLKEM_SECRETKEYBYTES] = __crypto_kem_keypair_jazz(spkp[0:MLKEM_PUBLICKEYBYTES], expanded_sk[0:MLKEM_SECRETKEYBYTES], expanded[0:XWING_BYTES*2]);   
  spkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES] = xwing_x25519_base(spkp[MLKEM_PUBLICKEYBYTES:X25519_BYTES], expanded[XWING_BYTES*2:X25519_BYTES]);
  in[0:MLKEM_SYMBYTES] = __crypto_kem_dec_jazz(in[0:MLKEM_SYMBYTES], sctp[0:MLKEM_CIPHERTEXTBYTES], expanded_sk[0:MLKEM_SECRETKEYBYTES]);
  in[MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES] = xwing_x25519(in[MLKEM_SYMBYTES + X25519_BYTES:X25519_BYTES], expanded_sk[MLKEM_SECRETKEYBYTES:XWING_BYTES], sctp[MLKEM_CIPHERTEXTBYTES:X25519_BYTES]);
  
  sshkp = _sha3_256_A6__A128(sshkp, in);
  
  () = #unspill(shkp);  
  
  shkp = #copy(sshkp);
  return shkp;
}

