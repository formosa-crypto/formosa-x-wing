from Keccak require "avx2/keccak1600_imem_avx2.jinc"
from Keccak require "avx2/keccak1600x4_imem_avx2.jinc"
require "params.jinc"


namespace A6 {
  param int ASIZE = 6;
  from Keccak require "avx2/keccak1600_array_avx2_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_array_avx2_ASIZE.jinc"
}

namespace A96 {
  param int ASIZE = 96;
  from Keccak require "avx2/keccak1600_array_avx2_ASIZE.jinc"
  from Keccak require "avx2/keccak1600x4_array_avx2_ASIZE.jinc"
}

fn _shake256_A96__A32
(   #spill_to_mmx reg mut ptr u8[96] out
   , reg const ptr u8[32] in
) -> reg ptr u8[96]
{ reg u256[7] st;
  reg u64 offset;
  st = __state_init_avx2();
  offset = 0;
  st, _ = A32::__absorb_array_avx2(st, in, offset, 32, R136, SHAKE);
  offset = 0;
  out, _ = A96::__squeeze_array_avx2(out, offset, 96, st, R136);
  return out; }


/*
def Combiner(ss_M, ss_X, ct_X, pk_X):
     return SHA3-256(concat(
       ss_M,
       ss_X,
       ct_X,
       pk_X,
       XWingLabel
     ))
 */
fn _sha3_256_A128__A6
( #spill_to_mmx reg mut ptr u8[32] out
, reg const ptr u8[32] ss_mlkem
, reg const ptr u8[32] ss_x25519
, reg const ptr u8[32] ct_x25519
, reg const ptr u8[32] pk_x25519
) -> reg ptr u8[32]
{ reg u256[7] st;
  stack u64[25] pst;
  reg u64 offset;
  st = __state_init_avx2();
  pst = __pstate_init_avx2(pst);
  offset = 0;
  pst, _, st, _ = A32::__pabsorb_array_avx2(pst, 0, st, ss_mlkem, offset, 32, R136, UNFINISHED);
  offset = 0;
  pst, _, st, _ = A32::__pabsorb_array_avx2(pst, 32, st, ss_x25519, offset, 32, R136, UNFINISHED);
  offset = 0;
  pst, _, st, _ = A32::__pabsorb_array_avx2(pst, 64, st, ct_x25519, offset, 32, R136, UNFINISHED);
  offset = 0;
  pst, _, st, _ = A32::__pabsorb_array_avx2(pst, 96, st, pk_x25519, offset, 32, R136, UNFINISHED);
  offset = 0;
  pst, _, st, _ = A6::__pabsorb_array_avx2(pst, 128, st, XWING_LABEL, offset, 6, R136, SHA3);
  offset = 0;
  out, _ = A32::__squeeze_array_avx2(out, offset, 32, st, R136);
  return out;
}
